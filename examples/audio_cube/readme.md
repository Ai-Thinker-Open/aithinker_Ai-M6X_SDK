```bash

$ make APP=audio_cube BOARD=bl706_avb

isp 协议 测试

isp 协议 实现方式：

    isp_uart_init 函数为 串口初始化

    isp_task_handler 函数为 接收 处理 数据的主要实现，若需要实现超时处理功能，需要定时调用。 需要传入数据地址和size，size可以为0表示无数据，可以用来处理超时。
    只有在等待ACK或者帧空闲时允许接收数据，接收到数据后按照协议解析内容。
    若是在等待ACK，接收到ACK后会调用注册好的回调函数。
    若是空闲状态，判断接收的数据来区分命令和数据包，
    收到命令或数据包后会调用回调函数。
    若是数据包退出回调后会自动根据校验回复ACK或NACK，不要自动回复把auot_ack写1就可,但需要自己去合适的地方回复ack。
    命令帧不会自动回复ACK，需要在回调里结合具体命令类型，去回复2字节信息或者直接开始发送数据包

    isp_uart_send_data 函数 为发送数据包或命令，isp_uart_send_data 函数只允许在帧状态机空闲时发送数据或命令，避免冲突。预期是放在回调函数里使用。
    在发送数据时，命令或数据包的帧头部分会使用阻塞发送，但是数据部分会使用DMA-UART方式发送，启动DMA后立即返回，并在DMA结束中断里调用回调函数，并将进入等待 ACK 状态，

    回调函数需要自己根据需求来设计，isp触发事件后会调用回调函数，并传入触发原因，预期中流程是：

    连续上传数据包  1.上位机给出命令 --> 2.触发命令回调，发送第一个数据包(文件名) --> 3.发完等待ACK --> 4.收到ACK,触发ACK回调 --> 5.继续发送下一个数据包--> 回到步骤 3
        问题：发送中间上位机如何发送其他命令包进行其他操作？

    下传数据包  1.上位机直接发出数据包 --> 2.触发WAIT_ACK回调 --> 3.回调里完成数据操作,退出回调后自动完成ACK --> 4.上位机发送数据包，回到步骤1
                                                                                                |______-----> 5.上位机发送命令包，其他操作



```